package thread;

//接下来学习一些线程的操作
public class Thread03 {
    public static void main(String[] args) {
/*
1、怎么获取当前线程对象？
    其实就是获得了一个栈的对象，可以把线程想象成一个栈
    Thread t = Thread.currentThread();
    返回值t就是当前线程。

2、获取线程对象的名字
    String name = 线程对象.getName();

3、修改线程对象的名字
    线程对象.setName("线程名字");

4、当线程没有设置名字的时候，默认的名字有什么规律？（了解一下）
    main
    Thread-0
    Thread-1
    Thread-2
    Thread-3
    .....
 */
// 线程对象.setPriority(参数) 线程对象.getPriority()
//           设置与获得线程抢夺时间片的优先级
// 注意点：
//        1.参数的取值范围为int的[1,10]其他值会抛出异常，Thread中提供三个参数
//          Thread.MAX_PRIORITY 10
//          Thread.NORM_PRIORITY 5
//          Thread.MIN_PRIORITY  1
//        2.可以在start()后设置
//        3，优先级较高的，只是抢到的CPU时间片相对多一些，大概率方向更偏向于优先级比较高的。
//        每个优先级会存在一个线程队列，同一对队列之间也会依次出来抢夺时间，但在队列后的抢的可能性小于前的，但区别不大

/*
关于线程的Thread.sleep(参数)方法和线程对象.interrupt()方法：
    static void sleep(long millis)
    1、静态方法：Thread.sleep(1000);
    2、参数是毫秒
    3、作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其它线程使用。
    且在该时间段内不抢占cpu时间
        这行代码出现在A线程中，A线程就会进入休眠。
        这行代码出现在B线程中，B线程就会进入休眠。
    4、当睡眠结束会重新回到就绪状态抢夺时间片，继续执行余下代码
    5、sleep采用异常中断措施，该异常就是来打断休眠的，  t.interrupt()就可以终止某个线程的休眠
    5、sleep采用异常中断措施，该异常就是来打断休眠的，  t.interrupt()就可以终止某个线程的休眠

 */
/*Thread.yield()
让位，当前线程暂停，回到就绪状态，让给其它线程。
静态方法：Thread.yield();
有点类似Thread.sleep(0)

Thread.yield()和Thread.sleep(0)语义实现取决于具体的jvm虚拟机，某些jvm可能什么都不做，
而大多数虚拟机会让线程放弃剩余的cpu时间片，重新变为runnable状态，并放到同优先级线程队列
的末尾等待cpu资源。 但是当我们调用Thread.yield()的那一刻，并不意味着当前线程立马释放cpu
资源，这是因为获得时间片的线程从runable切换到running仍需要一定的准备时间，这段时间当前线程
仍可能运行一小段时间。

 */
/* 线程对象.join()
    合成线程，其实是类合成，即使异步变成同步，线程对象合并到当前线程中，当前线程受阻塞，线程对象执行直到结束，再执行当前线程，
    不会改变优先级，跟sleep一样，会被interrupt()打断，打断后俩个线程正常执行，注意该为实例方法

*/
/* 线程对象a.setDaemon(true)
        将此线程a设置当前所在线程的守护线程，当前线程一结束，守护线程就会被死亡
        一般用于把日志或一些后台检测代码写成死循环，然后设为守护线程，非常好用
   注意点1:
        1,注意在start()前设置，不然会抛出异常,默认值为false，所以不调用就不是守护线程
*/

// 线程对象.stop()方法：
//        用来终止某线程的执行，直接进入死亡阶段
//        已经被废弃，因为是突然中止，可能在线程中开辟一些流没关，等一些操作来不及处理就被强行关闭，所以不安全
//        可以在线程类中创造一个布尔变量，然后run中加入一个if else去判断这个布尔然后是否执行run中部分操作，否则就执行一些
//        else的收尾操作
//        但很显然这样不够灵活

    }
}
